<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 对象的深拷贝 · Jax Blog</title><meta name="description" content="对象的深拷贝 - Jax"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jaxcode.github.io/atom.xml" title="Jax Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jaxcode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">对象的深拷贝</h1><div class="post-info">2017年4月14日</div><div class="post-content"><p>了解对象的深拷贝之前，我们需要知道对象的拷贝和普通的拷贝有什么不同。<br><a id="more"></a></p>
<h3 id="数据类型的不同"><a href="#数据类型的不同" class="headerlink" title="数据类型的不同"></a>数据类型的不同</h3><p>js根据数据类型的不同可以分为：基础数据类型和引用数据类型。</p>
<p>基础数据类型包括：<code>number</code> <code>string</code> <code>null</code> <code>undefined</code> <code>boolean</code>。引用数据类型包括：<code>array</code> <code>object</code>。</p>
<p>基础数据类型并不存在深拷贝的问题，来看看他们的区别：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 基础类型</span></div><div class="line"><span class="keyword">var</span> str1 = <span class="string">'aaa'</span>;</div><div class="line"><span class="keyword">var</span> str2 = str1;</div><div class="line">str2 = <span class="string">'bbb'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str1 === str2); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(str1, str2); <span class="comment">// aaa bbb</span></div><div class="line"></div><div class="line"><span class="comment">// 引用类型</span></div><div class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'jax'</span> &#125;;</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">obj2.name = <span class="string">'leo'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;name: "leo"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;name: "leo"&#125;</span></div></pre></td></tr></table></figure></p>
<p>显而易见的，基础类型不会影响被拷贝对象的值，而引用类型会。这是因为基础类型的拷贝会重新开辟内存空间存放值， 而引用类型的拷贝是指向同一个内存地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 基础类型</div><div class="line"></div><div class="line">指针       值          指针       值</div><div class="line">str1 ==&gt; &apos;aaa&apos;        str1 ==&gt; &apos;aaa&apos;</div><div class="line">str2 ==&gt; &apos;aaa&apos;        str2 ==&gt; &apos;bbb&apos;</div><div class="line"></div><div class="line"># 引用类型</div><div class="line"></div><div class="line">指针                   栈区值                 </div><div class="line">obj1      ==&gt;         obj1对象在堆区的地址</div><div class="line">obj2      ==&gt;         obj1对象在堆区的地址</div><div class="line"></div><div class="line">堆区地址                堆区值</div><div class="line">obj1对象在堆区的地址 ==&gt; obj1对象</div></pre></td></tr></table></figure></p>
<p>也就是说对于引用类型的拷贝，不会在内存堆中重新开辟空间存放数据，而只会新增一个指向数据的指针。</p>
<p>这就导致了我们修改obj2的值，obj1也会跟着改变。因为它们本质上读取和修改的是同一个内存地址的数据。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>如果我们不想要修改一个，另一个就跟着变化。我们可以用浅拷贝来解决这个问题。</p>
<p>对象的浅拷贝: 用<code>for in</code>循环生成一个键和值都与原对象相同的新对象。</p>
<p>数组的浅拷贝: <code>slice</code>函数等方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象的浅拷贝</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">        res[key] = obj[key];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'jax'</span> &#125;;</div><div class="line"><span class="keyword">var</span> obj2 = shallowCopy(obj1);</div><div class="line">obj2.name = <span class="string">'leo'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;name: "jax"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;name: "leo"&#125;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组的浅拷贝</span></div><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">// 以下方法都行</span></div><div class="line"><span class="keyword">var</span> arr2 = arr1.slice(<span class="number">0</span>);</div><div class="line"><span class="comment">// var arr2 = arr1.concat();</span></div><div class="line"><span class="comment">// var arr2 = Array.from(arr1); // es6</span></div><div class="line"><span class="comment">// var arr2 = [...arr1]; // es6</span></div><div class="line"></div><div class="line">arr2.push(<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
<p>值得注意的是，当对象的数据结构变的更加复杂的时候，浅拷贝可能就满足不了我们的需求了。比如对象中又包含了一个对象的这种情况，而浅拷贝实现的<code>for in</code>循环只会循环第一层的数据结构。</p>
<h3 id="JSON方法实现的深拷贝"><a href="#JSON方法实现的深拷贝" class="headerlink" title="JSON方法实现的深拷贝"></a>JSON方法实现的深拷贝</h3><p>我们可以用<code>JSON.parse</code>和<code>JSON.stringify</code>来实现对象深拷贝的功能。</p>
<p><code>JSON.stringify</code>: 将一个JavaScript值转换为一个JSON字符串。</p>
<p><code>JSON.parse</code>：解析一个JSON字符串，构造由字符串描述的JavaScript值或对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'jax'</span>,</div><div class="line">    <span class="attr">todo</span>: &#123; <span class="attr">title</span>: <span class="string">'title1'</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = shallowCopy(obj1); <span class="comment">// 浅拷贝</span></div><div class="line"><span class="keyword">var</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">// 深拷贝</span></div><div class="line"></div><div class="line">obj2.todo.title = <span class="string">'title2'</span>;</div><div class="line">obj3.todo.title = <span class="string">'title3'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1.todo.title); <span class="comment">// title2 // 由于obj2是浅拷贝, 所以obj1的todo对象的值也被修改了</span></div><div class="line"><span class="built_in">console</span>.log(obj2.todo.title); <span class="comment">// title2</span></div><div class="line"><span class="built_in">console</span>.log(obj3.todo.title); <span class="comment">// title3</span></div></pre></td></tr></table></figure>
<div class="tip"><br>    JSON的这两个方法在低版本浏览器存在兼容性问题，你可以下载json2.js来解决。<br></div>

<p>用这种方式来实现深拷贝固然很方便，但无奈有bug，它会删掉function函数(es6写法也会被删除)，所以鉴于它的通用性不足。我们需要写一个深拷贝函数。</p>
<h3 id="递归实现的深拷贝"><a href="#递归实现的深拷贝" class="headerlink" title="递归实现的深拷贝"></a>递归实现的深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            res[key] = deepCopy(obj[key]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            res[key] = obj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'jax'</span>,</div><div class="line">    <span class="attr">todo</span>: &#123; <span class="attr">title</span>: <span class="string">'title1'</span> &#125;,</div><div class="line">    <span class="attr">click</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = deepCopy(obj1);</div><div class="line"></div><div class="line">obj2.todo.title = <span class="string">'title2'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1.todo.title); <span class="comment">// title1</span></div><div class="line"><span class="built_in">console</span>.log(obj2.todo.title); <span class="comment">// title2</span></div></pre></td></tr></table></figure>
<p>在<code>for in</code>循环的时候，用typeof检测了<code>obj[key]</code>的值，来判断有没有存在对象包含对象的情况。如果存在的则递归调用拷贝函数。</p>
<p>但是当我们的目标对象变得更加复杂的时候，比如对象中包含数组的情况。这个类型检测就无法达到我们的要求。因为数组和对象是无法使用<code>typeof</code>来区分的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"></div><div class="line"><span class="comment">// typeof 无法判断数组和对象的类型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr === <span class="string">'object'</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 下面两种方法都可以区分数组和对象</span></div><div class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Array</span>); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj)); <span class="comment">// [object Object]</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// [object Array]</span></div></pre></td></tr></table></figure>
<p>虽然上面两种方式都可以区分数组和对象。但是建议使用<code>Object.prototype.toString.call()</code>方式。原因是:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// null 类型会存在 bug</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.constructor); <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p>类型判断可能会在项目的其他用到，所以我们可以封装成一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="built_in">Object</span>.prototype.toString.call(obj);</div><div class="line">    res = res.replace(<span class="regexp">/\[object (.+?)\]/i</span>, <span class="string">'$1'</span>).toLowerCase();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type(<span class="number">1</span>)); <span class="comment">// number</span></div><div class="line"><span class="built_in">console</span>.log(type(<span class="string">'a'</span>)); <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(type([])); <span class="comment">// array</span></div><div class="line"><span class="built_in">console</span>.log(type(&#123;&#125;)); <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(type(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(type(<span class="literal">null</span>)); <span class="comment">// null</span></div><div class="line"><span class="built_in">console</span>.log(type(<span class="literal">true</span>)); <span class="comment">// boolean</span></div><div class="line"><span class="built_in">console</span>.log(type(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)); <span class="comment">// function</span></div></pre></td></tr></table></figure></p>
<p>使用类型判断函数来实现深拷贝函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> t = type(obj);</div><div class="line">    <span class="keyword">if</span> (t === <span class="string">'array'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> res = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</div><div class="line">            res.push(deepCopy(obj[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t === <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> res = &#123;&#125;;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">            res[key] = deepCopy(obj[key]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="built_in">Object</span>.prototype.toString.call(obj);</div><div class="line">    res = res.replace(<span class="regexp">/\[object (.+?)\]/i</span>, <span class="string">'$1'</span>).toLowerCase();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际的工作项目中，并不见得说一定要使用深拷贝。还是要具体情况具体分析。</p>
<p>嗯。就这样。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/13/我的chrome插件集/" class="prev">PREV</a><a href="/2017/04/15/完整的AJAX流程/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="http://jaxcode.github.io">Jax</a>, email: 13486062822@163.com</p><script src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>