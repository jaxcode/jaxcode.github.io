<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> this指向总结 · Jax Blog</title><meta name="description" content="this指向总结 - Jax"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jaxcode.github.io/atom.xml" title="Jax Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jaxcode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">this指向总结</h1><div class="post-info">2017年4月17日</div><div class="post-content"><p>在学习js的过程中, 关于this的指向你一定听过这么一句话. 谁调用的, this就指向谁. 但这句话并不准确.</p>
<a id="more"></a>
<h3 id="this的基础概念"><a href="#this的基础概念" class="headerlink" title="this的基础概念"></a>this的基础概念</h3><p><code>this</code>的指向, 是在被调用的时候确定的. 调用的方式不同, <code>this</code>指向不同.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn(); <span class="comment">// 直接调用 // 1</span></div><div class="line">fn.call(obj); <span class="comment">// 绑定obj调用 // 2</span></div></pre></td></tr></table></figure></p>
<h3 id="全局对象的this指向"><a href="#全局对象的this指向" class="headerlink" title="全局对象的this指向"></a>全局对象的this指向</h3><p>全局对象的<code>this</code>指向他的自身 (浏览器端是<code>window</code>, node中是<code>global</code>)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>在全局环境中, 声明一个变量, 变量指向自身.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// 显示</span></div><div class="line">b = <span class="number">2</span>; <span class="comment">// 隐式</span></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<div class="tip"><br>在没有通过<code>var</code>声明的情况下直接赋值, 会把变量隐式绑定到全局对象中, 这是不推荐的.<br></div>


<h3 id="函数中的this指向"><a href="#函数中的this指向" class="headerlink" title="函数中的this指向"></a>函数中的this指向</h3><ol>
<li><p>函数的<code>this</code>指向, 由调用函数的方式决定.</p>
</li>
<li><p>如果调用者函数被一个对象所拥有, <code>this</code>指向该对象.</p>
</li>
<li><p>如果函数独立调用, 严格模式中, this指向<code>undefined</code>.</p>
</li>
<li><p>在非严格模式中, 当<code>this</code>指向<code>undefined</code>时, 会自动指向全局对象.</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非严格模式</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.fn()); <span class="comment">// 2</span></div><div class="line"><span class="comment">// 此时调用者函数被对象拥有, this指向对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> fn = obj.fn;</div><div class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 1</span></div><div class="line"><span class="comment">// 此时函数为独立调用, this指向undefined, 在非严格模式下, 自动指向全局对象</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 严格模式</span></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.fn()); <span class="comment">// 2</span></div><div class="line"><span class="comment">// 此时调用者函数被对象拥有, this指向对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> fn = obj.fn;</div><div class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 报错</span></div><div class="line"><span class="comment">// 此时函数为独立调用, this指向undefined</span></div></pre></td></tr></table></figure>
<h3 id="对象中的this指向"><a href="#对象中的this指向" class="headerlink" title="对象中的this指向"></a>对象中的this指向</h3><ol>
<li><p>当对象在全局声明时, this指向全局对象.</p>
</li>
<li><p>当对象在函数中声明时, 严格模式中, this指向<code>undefined</code>.</p>
</li>
<li><p>在非严格模式中, 当<code>this</code>指向<code>undefined</code>时, 会自动指向全局对象.</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局声明, this指向全局</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">b</span>: <span class="keyword">this</span>.a + <span class="number">10</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// 11</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非严格模式</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">b</span>: <span class="keyword">this</span>.a + <span class="number">10</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj.b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 11</span></div><div class="line"><span class="comment">// 对象在函数中声明, this指向undefined, 在非严格模式下, 自动指向全局对象</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 严格模式</span></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">b</span>: <span class="keyword">this</span>.a + <span class="number">10</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj.b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 报错</span></div><div class="line"><span class="comment">// 对象在函数中声明, this指向undefined</span></div></pre></td></tr></table></figure>
<h3 id="构造函数的this指向"><a href="#构造函数的this指向" class="headerlink" title="构造函数的this指向"></a>构造函数的this指向</h3><ol>
<li><p>当做构造函数来调用时, <code>this</code>指向调用时实例化出来的对象.</p>
</li>
<li><p>当做普通函数执行, <code>this</code>指向的判断与上文提到的函数<code>this</code>指向判断方法相同.</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> jax = <span class="keyword">new</span> Person(<span class="string">'jax'</span>);</div><div class="line"><span class="built_in">console</span>.log(jax.name); <span class="comment">// jax</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当做普通函数执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> jax = Person(<span class="string">'jax'</span>);</div></pre></td></tr></table></figure>
<div class="tip"><br>如果在构造函数中返回了一个对象, 那么<code>this</code>会指向返回的对象.<br></div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">'leo'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> jax = <span class="keyword">new</span> Person(<span class="string">'jax'</span>);</div><div class="line"><span class="built_in">console</span>.log(jax.name); <span class="comment">// leo</span></div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/15/完整的AJAX流程/" class="prev">PREV</a><a href="/2017/04/17/FormData和AJAX上传/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="http://jaxcode.github.io">Jax</a>, email: 13486062822@163.com</p><script src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>